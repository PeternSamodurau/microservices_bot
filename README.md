Моя работа начинается в тот момент, когда вы отправляете мне сообщение. Вот пошаговый процесс, который происходит "за кулисами":

1.  **Вы отправляете сообщение:**
    *   Вы в своём приложении Telegram пишете сообщение или команду (например, `/start`, `/help`, `/cancel`, `/registration`, или просто отправляете текст, документ, фото) в **конкретный чат со мной**. Для вас это прямое общение с ботом.

2.  **Сообщение поступает в Telegram:**
    *   Ваше сообщение отправляется с вашего устройства на **серверы Telegram**.
    *   На этих серверах существует **логическое представление меня (Telegram Bot)**. Именно эта сущность получает сообщение от вас внутри экосистемы Telegram.
    *   **Telegram API** – это программный интерфейс, который позволяет моему приложению (расположенному на отдельном сервере) взаимодействовать с этим логическим ботом в Telegram. Моё приложение постоянно 'опрашивает' Telegram API на предмет новых сообщений.

3.  **Сообщение достигает моего "Диспетчера":**
    *   Как только на серверах Telegram появляется новое сообщение для меня, оно передается в главный входной узел моего приложения – **Диспетчер**.
    *   Диспетчер состоит из двух основных частей: **TelegramBotController** (который получает сообщения от Telegram) и **UpdateBotController** (который их маршрутизирует).

4.  **Диспетчер определяет тип сообщения:**
    *   **UpdateBotController** – это "мозг" Диспетчера. Его задача – определить тип полученного сообщения (текст, документ или фотография), анализируя его содержимое.
    *   После определения типа, сообщение **немедленно отправляется в специальную очередь** для асинхронной обработки. Это позволяет мне мгновенно освободиться для приема новых сообщений, не дожидаясь окончания всей сложной обработки.

5.  **Сообщение поступает в очереди RabbitMQ:**
    *   Ваше сообщение попадает в одну из следующих **очередей RabbitMQ** (система брокера сообщений), в зависимости от его типа:
        *   Для текстовых сообщений: `text_message_update`
        *   Для документов: `doc_message_update`
        *   Для фотографий: `photo_message_update`
    *   Существует также очередь `answer_message` для моих ответов вам.

6.  **Начало основной обработки (внутри "NODE"):**
    *   Как только ваше сообщение оказывается в очереди, его "подхватывает" специальный слушатель – **ConsumerServiceImpl**. Он **неявно** (без прямого вызова из предыдущих частей, Spring сам активирует его) получает сообщение из очереди.
    *   **ConsumerServiceImpl** передает ваше сообщение в **MainServiceImpl** – это ядро всей моей бизнес-логики.

7.  **Сохранение данных и идентификация пользователя:**
    *   **Всегда, первым делом**, весь полученный от Telegram объект `Update` **сохраняется в базе данных** (в таблице `raw_data`). Это гарантирует, что у меня всегда есть полная запись всех необработанных данных, пришедших от Telegram, что важно для анализа и отладки.
    *   Затем я пытаюсь **идентифицировать вас как пользователя**:
        *   Я проверяю свою базу данных (`app_user` таблица) на наличие вашей записи по вашему уникальному идентификатору Telegram.
        *   **Если вы новый пользователь**, я создаю для вас новую запись в базе данных. По умолчанию ваша учетная запись будет считаться активной (`isActive=true`), и вы будете находиться в **базовом состоянии (`BASIC_STATE`)**.
        *   **Если вы уже существуете**, я просто загружаю ваши данные из базы.
    *   После этого я определяю ваше **текущее состояние** (`appUserState`), что важно для понимания контекста вашего сообщения (например, ожидаю ли я от вас ввод email, или вы просто отправляете обычную команду).

8.  **Выполнение логики по сценарию (внутри "NODE" - MainServiceImpl):**
    Мои дальнейшие действия зависят от типа сообщения и вашего текущего состояния:

    *   **Если вы отправили текстовое сообщение (команду или текст):**
        *   Я анализирую текст сообщения, учитывая ваше текущее состояние.
        *   **Если вы находитесь в `BASIC_STATE` (базовом состоянии):**
            *   **Команда `/start`**: Я формирую приветственное сообщение: "Привет! Чтобы посмотреть список доступных команд введите /help".
            *   **Команда `/help`**: Я предоставляю вам список доступных команд: "Список доступных команд:\n/cancel - отмена выполнения текущей комады;\n/registration - регистрация пользователя;".
            *   **Команда `/cancel`**: Я подтверждаю отмену: "Команда отменена!" и убеждаюсь, что ваше состояние сброшено в `BASIC_STATE` в базе данных. Это гарантирует возврат к начальному состоянию, даже если вы уже были в нём.
            *   **Команда `/registration`**: В текущей версии я сообщаю: "Временно не доступно!".
            *   **Любая другая команда или обычный текст**: Я отвечаю: "Неизвестная команда! Чтобы посмотреть список доступных команд введите /help".
        *   **Если вы находитесь в `WAIT_FOR_EMAIL_STATE` (состояние ожидания ввода email):**
            *   В текущей версии эта функция находится в разработке. Здесь я буду ожидать от вас ввод email для регистрации.
        *   После этого я перехожу к подготовке ответа.

    *   **Если вы отправили документ или фотографию:**
        *   Я проверяю, что ваша учетная запись активна и вы находитесь в `BASIC_STATE`.
        *   **Если все условия соблюдены**, я передаю задачу обработки вашего файла специализированному сервису **FileServiceImpl**.
            *   **FileServiceImpl** скачивает ваш файл из Telegram API (используя его уникальный идентификатор и путь на серверах Telegram) и сохраняет его метаданные, а также само содержимое, в базу данных (`app_document` и `binary_content`).
        *   После успешного сохранения файла, я формирую для вас подтверждающее сообщение, например: "Документ успешно загружен! Ссылка для скачивания: http://test.ru/get-doc/777" (обратите внимание, ссылки пока являются заглушками).
        *   После этого я перехожу к подготовке ответа.

9.  **Подготовка ответа и его отправка в очередь RabbitMQ:**
    *   После того как я сформировал окончательный ответ, я создаю объект `SendMessage` (это сообщение, которое будет отправлено вам).
    *   Этот `SendMessage` объект передается в **ProducerServiceImpl**.
    *   Задача **ProducerServiceImpl** – отправить этот `SendMessage` в специальную очередь RabbitMQ под названием `answer_message`. Этот шаг вновь происходит асинхронно, позволяя моей основной логике завершиться без задержек.

10. **Получение ответа из очереди для финальной отправки:**
    *   Мой сервис **AnswerConsumerImpl** постоянно слушает очередь `answer_message`.
    *   Как только в этой очереди появляется `SendMessage` объект, **AnswerConsumerImpl** **неявно** его подхватывает.
    *   Задача **AnswerConsumerImpl** – передать этот `SendMessage` обратно в **UpdateBotController** (который был частью моего Диспетчера).

11. **Финальная отправка ответа в Telegram:**
    *   **UpdateBotController** получает готовый `SendMessage` объект.
    *   Он делегирует его **TelegramBotController**.
    *   **TelegramBotController** использует функции библиотеки TelegramBots для выполнения **HTTP-запроса к Telegram API** (то есть, к серверам Telegram), отправляя сформированный `SendMessage` объект.

12. **Доставка ответа вам:**
    *   **Telegram API** принимает мой ответ и доставляет его в ваше приложение Telegram. Вы видите мое сообщение!